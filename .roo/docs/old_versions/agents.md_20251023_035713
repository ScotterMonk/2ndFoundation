# AGENTS.md

This file provides guidance to agents when working with code in this repository.

## Run Commands
- Start app: `python app.py` (not `flask run`)
- Activate venv: `.\activate.ps1`
- Test: `pytest` (uses live PostgreSQL, not test DB)

## Critical Non-Standard Patterns

### Architecture: Core vs Presentation Separation
- `utils/*_core.py` - stateless business logic (no Flask context)
- `routes/utils_*_*.py` - Flask-aware presentation utilities
- Routes delegate to presentation utils, which call core functions
- This separation is MANDATORY - never mix Flask imports into `*_core.py` files

### Database
- PostgreSQL ONLY - never SQLite (even for dev/test)
- DB instance imported from `utils/database.py` not created in `app.py`
- Database scripts: Write to `temp/` folder and run, never paste multi-line scripts in terminal
- TestingConfig intentionally has `WTF_CSRF_ENABLED = False`

### Route Helpers Pattern
- `utils/route_helpers.py` provides standardized response handling
- Always use `handle_util_result()`, `handle_simple_util_result()`, or `handle_delete_result()`
- These handle success/error states, flash messages, and redirects consistently

### Naming Convention
- Pattern: `{domain}_{specific}` not `{specific}_{domain}`
- Examples: `utils_admin_dashboard.py` not `admin_dashboard_utils.py`

### Code Standards
- All functions/classes MUST include: `# [Created-or-Modified] by [model] | yyyy-mm-dd`
- 4-space indentation
- Templates use `jinja-html` language mode

### Testing
- Querystring auth for local testing: `http://localhost:5000/auth/login?email=[creds]&password=[hashed]`
- Puppeteer via MCP for browser automation (not Selenium)

### Documentation
- Backups: `.roo/docs/old_versions/[file name without extension]_[timestamp]_[extension]`
- Logs and completed plans: `.roo/docs/plans_completed/`
- Mode rules: `.roo/rules-*/01-*.md`
- DB schema changes logged in `.roo/docs/pgdb_changes.md`

## External API Provider Framework

### BaseApiProvider
- `utils/api_provider_core.py` contains the centralized `BaseApiProvider` class for all external API interactions
- This class handles HTTP requests, authentication, token management, error handling, and response normalization
- Stateless design with no Flask context dependencies - suitable for use in `*_core.py` files
- Includes built-in retry strategy and standardized response format
- Use this class instead of creating separate HTTP client code for each API

### Provider Descriptors
- `utils/api_provider_descriptors.py` defines configuration descriptors for all external APIs
- New API providers should be configured by adding a `DESCRIPTOR` dictionary in this file
- Descriptor-based approach is the standard - avoid creating separate utility files for each new API
- Each descriptor includes: base URL, authentication strategy, header builders, and normalization callbacks
- Supports multiple auth strategies: bearer tokens, API keys, static tokens
- Includes `TokenCache` class for automatic token refresh and caching

### Configuration
- All API-related settings (keys, URLs, timeouts) are centralized in `config.py`
- API credentials and configuration sourced from `.env` file
- Current providers configured: TVDB, TMDB, IMDB
- Settings include base URLs, API keys, timeouts, and connection parameters

### Core vs Presentation
- Core API logic belongs in `utils/*_core.py` files and should use `BaseApiProvider`
- Presentation logic in `routes/utils_*_*.py` files can call core functions
- This maintains separation between stateless business logic and Flask-aware utilities
- Never mix Flask imports into core API provider classes
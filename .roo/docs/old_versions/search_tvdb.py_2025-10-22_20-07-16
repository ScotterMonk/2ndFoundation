#!/usr/bin/env python3
"""
TVDB Search Script

This script searches for movies and TV shows using the TVDB API.

Usage:
    python search_tvdb.py "search query"

Docs:
    https://thetvdb.github.io/v4-api/
"""

import sys
import json
import os
from datetime import datetime, timedelta
import requests
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Constants
API_BASE_URL = "https://api4.thetvdb.com/v4"
TOKEN_FILE = os.path.join(os.path.dirname(__file__), '.tvdb_token')
API_KEY = os.getenv('TVDB_API_KEY')

if not API_KEY:
    print(json.dumps({
        "error": "TVDB_API_KEY not found in environment variables",
        "status": "error"
    }, indent=2))
    sys.exit(1)


def load_token():
    """Load existing token from file if valid."""
    if not os.path.exists(TOKEN_FILE):
        return None
    
    try:
        with open(TOKEN_FILE, 'r') as f:
            token_data = json.load(f)
        
        # Check if token is still valid (25 days from creation)
        created_at = datetime.fromisoformat(token_data['created_at'])
        expires_at = created_at + timedelta(days=25)
        
        if datetime.now() < expires_at:
            return token_data['token']
        else:
            return None
    except (json.JSONDecodeError, KeyError, ValueError):
        return None


def save_token(token):
    """Save token to file with creation timestamp."""
    token_data = {
        'token': token,
        'created_at': datetime.now().isoformat()
    }
    with open(TOKEN_FILE, 'w') as f:
        json.dump(token_data, f)


def authenticate():
    """Authenticate with TVDB API and return bearer token."""
    url = f"{API_BASE_URL}/login"
    headers = {'Content-Type': 'application/json'}
    data = {'apikey': API_KEY}
    
    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        
        result = response.json()
        token = result['data']['token']
        save_token(token)
        return token
        
    except requests.exceptions.RequestException as e:
        print(json.dumps({
            "error": f"Authentication failed: {str(e)}",
            "status": "error"
        }, indent=2))
        sys.exit(1)
    except (KeyError, json.JSONDecodeError) as e:
        print(json.dumps({
            "error": f"Invalid authentication response: {str(e)}",
            "status": "error"
        }, indent=2))
        sys.exit(1)


def get_valid_token():
    """Get a valid authentication token."""
    token = load_token()
    if not token:
        token = authenticate()
    return token


def search_tvdb(query):
    """Search TVDB for movies and TV shows."""
    token = get_valid_token()
    url = f"{API_BASE_URL}/search"
    headers = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }
    params = {'query': query}
    
    try:
        response = requests.get(url, headers=headers, params=params)
        
        if response.status_code == 401:
            # Token might be expired, try to re-authenticate
            token = authenticate()
            headers['Authorization'] = f'Bearer {token}'
            response = requests.get(url, headers=headers, params=params)
        
        response.raise_for_status()
        return response.json()
        
    except requests.exceptions.RequestException as e:
        return {
            "error": f"Search failed: {str(e)}",
            "status": "error"
        }

# Example response structure:
"""
{
  "data": [
    {
      "aliases": [
        {
          "language": "eng",
          "name": "Alternative Title"
        }
      ],
      "averageRuntime": 45,
      "country": "usa",
      "defaultSeasonType": 1,
      "firstAired": "2020-01-15",
      "id": 12345,
      "image": "/path/to/image.jpg",
      "lastAired": "2024-05-20",
      "name": "Example Series",
      "score": 95.5,
      "slug": "example-series",
      "status": {
        "id": 1,
        "name": "Continuing",
        "recordType": "series"
      },
      "year": "2020"
    }
  ]
}
"""

def list_tvdb_genres(lang="eng"):
    """Fetch list of TVDB genres."""
    token = get_valid_token()
    headers = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }
    params = {'lang': lang}
    url = f"{API_BASE_URL}/genres"
    try:
        resp = requests.get(url, headers=headers, params=params)
        if resp.status_code == 401:
            # Refresh token and retry once
            token = authenticate()
            headers['Authorization'] = f'Bearer {token}'
            resp = requests.get(url, headers=headers, params=params)
        resp.raise_for_status()
        body = resp.json()
        return body.get('data', []) or body.get('results', []) or []
    except requests.exceptions.RequestException:
        return []


def get_genre_id_by_name(name, lang="eng"):
    """Resolve a TVDB genre ID by exact genre name (case-insensitive)."""
    try:
        target = (name or "").strip().lower()
        if not target:
            return None
        genres = list_tvdb_genres(lang=lang)
        for g in genres:
            nm = (g.get('name') or "").strip().lower()
            if nm == target:
                return g.get('id')
        # Not found
        return None
    except Exception:
        return None
def search_media_by_genre(genre_id, country="usa", lang="eng", limit=20, offset=0, include=("series", "movie")):
    """Return combined list of TVDB series and movies for a genre, normalized.

    Returns:
        dict: {
            "data": [
                {
                    "tvdb_id": ...,
                    "title": ...,
                    "year": ...,
                    "status": ...,
                    "type": "series" | "movie",
                    "score": ...,
                    "image": ...,
                    "slug": ...,
                    "country": ...
                }
            ]
        }
    """
    token = get_valid_token()
    headers = {
        'Authorization': f'Bearer {token}',
        'Content-Type': 'application/json'
    }
    results = []

    def _request_data(url, params):
        resp = requests.get(url, headers=headers, params=params)
        if resp.status_code == 401:
            new_token = authenticate()
            headers['Authorization'] = f'Bearer {new_token}'
            resp = requests.get(url, headers=headers, params=params)
        resp.raise_for_status()
        body = resp.json()
        return body.get('data', body.get('results', [])) or []

    # Series
    if "series" in include:
        series_params = {
            "genre": genre_id,
            "country": country,
            "lang": lang,
            "sort": "score",
            "sortType": "desc",
            "offset": offset,
            "limit": limit
        }
        series_data = _request_data(f"{API_BASE_URL}/series/filter", series_params)
        for item in series_data:
            year_val = item.get("year") or item.get("firstAired")
            year = str(year_val)[:4] if year_val else ""
            status = item.get("status", {})
            status_name = status.get("name") if isinstance(status, dict) else status
            results.append({
                "tvdb_id": item.get("id") or item.get("tvdb_id"),
                "title": item.get("name") or item.get("title"),
                "year": year,
                "status": status_name,
                "type": "series",
                "score": item.get("score"),
                "image": item.get("image"),
                "slug": item.get("slug"),
                "country": item.get("country")
            })

    # Movies
    if "movie" in include or "movies" in include:
        movie_params = {
            "genre": genre_id,
            "country": country,
            "lang": lang,
            "sort": "score",
            "offset": offset,
            "limit": limit
        }
        movie_data = _request_data(f"{API_BASE_URL}/movies/filter", movie_params)
        for item in movie_data:
            year_val = item.get("year") or item.get("releaseYear") or item.get("firstAired")
            year = str(year_val)[:4] if year_val else ""
            status = item.get("status", {})
            status_name = status.get("name") if isinstance(status, dict) else status
            results.append({
                "tvdb_id": item.get("id") or item.get("tvdb_id"),
                "title": item.get("name") or item.get("title"),
                "year": year,
                "status": status_name,
                "type": "movie",
                "score": item.get("score"),
                "image": item.get("image"),
                "slug": item.get("slug"),
                "country": item.get("country")
            })

    # Sort by score desc (if present)
    results.sort(key=lambda x: (x.get("score") is not None, x.get("score") or 0), reverse=True)
    return {"data": results}

def main():
    """Main function to handle command-line arguments and execute the script."""
    if len(sys.argv) < 2:
        print(json.dumps({
            "error": "No search query provided",
            "usage": "python search_tvdb.py \"search query\"",
            "example": "python search_tvdb.py \"Breaking Bad\"",
            "status": "error"
        }, indent=2))
        sys.exit(1)
    
    # Join all arguments to handle multi-word queries
    query = ' '.join(sys.argv[1:])
    
    if not query.strip():
        print(json.dumps({
            "error": "Empty search query provided",
            "usage": "python search_tvdb.py \"search query\"",
            "example": "python search_tvdb.py \"Breaking Bad\"",
            "status": "error"
        }, indent=2))
        sys.exit(1)
    
    data = search_tvdb(query)
    
    # Output the raw JSON data directly from the API
    print(json.dumps(data, indent=2, ensure_ascii=False))


if __name__ == "__main__":
    main()
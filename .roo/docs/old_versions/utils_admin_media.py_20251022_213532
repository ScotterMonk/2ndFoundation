"""
Admin utility functions for media management.

This module contains utility functions for admin media operations that are called
from the main admin blueprint routes. Functions here should not have route decorators
as they are imported and used by admin.py.

Note: TVDB integration temporarily disabled; do not re-add imports from utils.utils_tvdb during plan 280925_api_cleanup.
"""

from flask import render_template, request, redirect, url_for, flash, current_app, jsonify
from flask_login import current_user
from flask_wtf.csrf import validate_csrf
from datetime import datetime, timezone
from sqlalchemy import func, and_, or_, distinct
from sqlalchemy.orm import joinedload
from utils.database import db
import re
import json

# Import required models
from models.models_user import User, UserType, UserAction
from models.models_media import Media, MediaType, Genre, MediaGenre, Director, MediaDirector, Performer, MediaPerformer

# Import utility functions from specialized modules
from routes.utils_admin_api import imdb_search_admin
from utils.imdb_core import imdb_id_normalize, imdb_item_normalize
# Import core media functions
from utils.media_core import merge_and_deduplicate_results
from utils.media import process_uploaded_files
# TVDB utilities temporarily disabled - removed import of attach_tvdb_util, _to_tvdb_item



def media_management_util():
    """
    Utility function to get media management data.
    
    This function handles the business logic for displaying and managing
    media items with metrics, search, and sorting.
    
    Returns:
        dict: Template data including media list, search results, and pagination
    """
    try:
        # Extract search term (supports 'q' and 'search')
        search_term = (request.args.get('q', '') or request.args.get('search', '')).strip()

        # Extract genre filter (optional). Do not apply filtering yet; just parse and pass through.
        genre_id_raw = (request.args.get('genre_id', '') or '').strip()
        selected_genre_id = None
        if genre_id_raw:
            try:
                gid = int(genre_id_raw)
                if gid > 0:
                    selected_genre_id = gid
            except (TypeError, ValueError):
                selected_genre_id = None
        
        # Get sorting parameters - default to title ascending
        sort = request.args.get('sort', 'title')
        direction = request.args.get('direction', 'asc')

        # Whitelist sortable columns
        # Support sorting by aggregated user rating (preferred)
        sort_map = {
            'title': Media.title,
            'type': MediaType.name,  # Will need join for media type name
            'rating_user': Media.user_rating_100,
            'rating_tmdb': Media.tmdb_rating,
            'created_at': Media.created_at,
            'director': Director.name
        }
        sort_col = sort_map.get(sort, Media.created_at)
        order_clause = sort_col.asc() if direction == 'asc' else sort_col.desc()

        # Base query for media, joining with User for search capabilities and MediaType for sorting
        # Use joinedload to eagerly load the media_type relationship
        base_query = (
            db.session.query(Media)
            .options(joinedload(Media.media_type))
            .join(User, Media.users_id == User.id)
            .join(MediaType, Media.media_type_id == MediaType.id)
        )

        # Apply search filter
        if search_term:
            pattern = f'%{search_term}%'
            conditions = [
                Media.title.ilike(pattern),
                User.username.ilike(pattern),
                User.email.ilike(pattern)
            ]
            if search_term.isdigit():
                conditions.append(Media.id == int(search_term))
            base_query = base_query.filter(or_(*conditions))

        # Apply genre filter when provided (AND with search)
        if selected_genre_id:
            # Use explicit join to the association table to follow existing query patterns
            base_query = base_query.join(
                MediaGenre, MediaGenre.media_id == Media.id
            ).filter(
                MediaGenre.genre_id == selected_genre_id
            )

        # Apply sorting and execute
        media_list = base_query.order_by(order_clause, Media.id.asc()).all()

        # Load genres for dropdown (do not fail page if this query errors)
        try:
            genres = Genre.query.order_by(Genre.name.asc()).all()
        except Exception as _e:
            current_app.logger.error(f"[DEBUG] Failed to load genres for admin.media: {_e}")
            genres = []

        # ===== IMDb SEARCH (title and/or genre) =====
        # Uses imdb_search_admin which calls utils.imdb_core functions
        imdb_results = imdb_search_admin(search_term, selected_genre_id)

        # Merge DB and IMDb search results using helper
        try:
            merged_results = merge_and_deduplicate_results(media_list, imdb_results)
        except Exception as _e:
            current_app.logger.error(f"[DEBUG] Failed to merge DB and IMDb results in admin.media: {_e}")
            merged_results = list(media_list or [])
        
        # Normalize merged results for sorting and template compatibility
        try:
            # Map DB ids to created_at to enrich merged items
            id_to_created = {}
            for m in (media_list or []):
                try:
                    if getattr(m, 'id', None) is not None:
                        id_to_created[m.id] = getattr(m, 'created_at', None)
                except Exception:
                    continue

            for item in merged_results:
                if not isinstance(item, dict):
                    # Safety: convert ORM objects to lightweight dict if any slipped through
                    try:
                        item = {
                            'id': getattr(item, 'id', None),
                            'title': getattr(item, 'title', '') or getattr(item, 'name', '') or '',
                            'type': (getattr(getattr(item, 'media_type', None), 'code', None) or getattr(getattr(item, 'media_type', None), 'name', None) or '').strip().lower(),
                            'user_rating_100': getattr(item, 'user_rating_100', None),
                            'source': 'DB'
                        }
                    except Exception:
                        continue
                # Provide user_rating_100 from rating_user if available (template expects this key)
                try:
                    if 'user_rating_100' not in item and item.get('rating_user') not in (None, '', 'N/A'):
                        item['user_rating_100'] = item.get('rating_user')
                except Exception:
                    pass
                # Attach created_at for DB-backed items to support created_at sort
                try:
                    if 'created_at' not in item and item.get('id') in id_to_created:
                        item['created_at'] = id_to_created.get(item.get('id'))
                except Exception:
                    pass
        except Exception as _norm_e:
            current_app.logger.error(f"[DEBUG] Merged results normalization error: {_norm_e}")

        # Sorting across merged results
        sort_field = (sort or 'created_at').strip().lower()
        reverse_order = (direction == 'desc')

        # Import helper functions from media_core for sorting
        from utils.media_core import _rating_value, _title_tuple, _type_tuple, _rating_tuple
        
        def _created_sort_tuple(i):
            dt = i.get('created_at') if isinstance(i, dict) else None
            if dt is None:
                # missing created_at always last
                return (1, 0.0)
            try:
                ts = dt.timestamp()
            except Exception:
                ts = 0.0
            # invert timestamp for desc while keeping missing last
            return (0, (-ts if reverse_order else ts))
        
        def _rating_tuple_with_direction(i):
            from utils.media_core import _rating_value
            v = _rating_value(i)
            if v is None:
                return (1, 0.0)  # missing last
            return (0, (-v if reverse_order else v))

        try:
            if sort_field == 'title':
                merged_results.sort(key=_title_tuple)
            elif sort_field == 'type':
                merged_results.sort(key=_type_tuple)
            elif sort_field == 'rating_user':
                merged_results.sort(key=_rating_tuple)
            elif sort_field == 'created_at':
                merged_results.sort(key=_created_sort_tuple)
            else:
                # Fallback to title sort
                merged_results.sort(key=_title_tuple)
        except Exception as _sort_e:
            current_app.logger.error(f"[DEBUG] Sorting merged results error: {_sort_e}")

        # Pagination (server-side) over merged results
        try:
            per_page = request.args.get('per_page', type=int) or 20
            if per_page <= 0:
                per_page = 20
            page = request.args.get('page', 1, type=int) or 1
            if page < 1:
                page = 1
            total = len(merged_results)
            pages = (total + per_page - 1) // per_page if per_page else 1
            if pages == 0:
                pages = 1
            if page > pages:
                page = pages
            start = (page - 1) * per_page
            end = start + per_page
            paged_results = merged_results[start:end] if per_page else merged_results
            pagination = {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': pages,
                'has_next': page < pages,
                'has_prev': page > 1
            }
        except Exception as _page_e:
            current_app.logger.error(f"[DEBUG] Pagination build error: {_page_e}")
            paged_results = merged_results
            pagination = {
                'page': 1,
                'per_page': len(merged_results),
                'total': len(merged_results),
                'pages': 1,
                'has_next': False,
                'has_prev': False
            }

        return {
            'success': True,
            'template': 'admin/media.html',
            'data': {
                'media': paged_results,
                'q': search_term,
                'sort': sort,
                'direction': direction,
                # Genre dropdown data and current selection
                'genres': genres,
                'genre_id': selected_genre_id,
                'selected_genre_id': selected_genre_id,
                # Pagination context for template (if/when rendered)
                'pagination': pagination,
                'page': pagination.get('page'),
                'per_page': pagination.get('per_page'),
                'results_count': pagination.get('total')
            }
        }

    except Exception as e:
        current_app.logger.error(f"[DEBUG] Error in media_management_util: {str(e)}")
        return {
            'success': False,
            'error': f'Error loading media management: {str(e)}',
            'status_code': 500
        }


def media_edit_util(media_id):
    """
    Utility function to handle media editing.
    
    This function handles the business logic for editing media items
    including form processing and validation.
    
    Args:
        media_id (int): The ID of the media item to edit
        
    Returns:
        dict: Result containing success status, template data, or response info
    """
    try:
        # Get the media item to edit with directors eagerly loaded
        media_item = (
            Media.query
            .options(joinedload(Media.media_directors).joinedload(MediaDirector.director))
            .get_or_404(media_id)
        )
        
        # Get media types for dropdown
        media_types = MediaType.query.order_by(MediaType.name.asc()).all()
        
        if request.method == 'GET':
            # Load all genres for dropdown (ordered by name)
            genres_all = Genre.query.order_by(Genre.name.asc()).all()
            return {
                'success': True,
                'template': 'admin/media_edit.html',
                'data': {
                    'media': media_item,
                    'media_types': media_types,
                    'genres_all': genres_all
                }
            }
        
        # POST request processing
        try:
            current_app.logger.info(f"[DEBUG] media_edit POST started for media_id: {media_id}")
            current_app.logger.info(f"[DEBUG] Form data received: {dict(request.form)}")
            
            # Validate CSRF token if enabled
            if current_app.config.get('WTF_CSRF_ENABLED') is True:
                try:
                    validate_csrf(request.form.get('csrf_token'))
                    current_app.logger.info("[DEBUG] CSRF token validation passed for edit_media")
                except Exception as e:
                    current_app.logger.error(f"[DEBUG] CSRF token validation failed for edit_media: {str(e)}")
                    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                        return {'success': False, 'json_response': {'success': False, 'error': 'Security token validation failed'}}
                    return {
                        'success': False,
                        'message': 'Security token validation failed. Please try again.',
                        'message_type': 'error',
                        'redirect': url_for('admin.media_edit', media_id=media_id)
                    }
            
            # Extract form data
            title = request.form.get('title', '').strip()
            description = request.form.get('description', '').strip()
            media_type_id = request.form.get('media_type_id', type=int)
            is_featured = request.form.get('is_featured') == 'on'
            adult = request.form.get('adult') == 'on'
            min_age = request.form.get('min_age', 0, type=int)
            # IMDb rating posted in UI uses 0-100 scale; store 0-100 in DB
            imdb_rating = request.form.get('imdb_rating', type=float)
            if imdb_rating is None:
                # Back-compat fallback if old field name is posted
                imdb_rating = request.form.get('rating_imdb', type=float)
            imdb_id = request.form.get('imdb_id', '').strip()
            release_date_str = request.form.get('release_date', '').strip()
            
            # Validate required fields
            current_app.logger.info(f"[DEBUG] Validating required fields - title: '{title}', media_type_id: {media_type_id}")
            
            if not title:
                error_msg = 'Title is required'
                if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                    return {'success': False, 'json_response': {'success': False, 'error': error_msg}}
                return {
                    'success': False,
                    'message': error_msg,
                    'message_type': 'error',
                    'template': 'admin/media_edit.html',
                    'data': {'media': media_item, 'media_types': media_types}
                }
            
            if not media_type_id:
                error_msg = 'Media type is required'
                if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                    return {'success': False, 'json_response': {'success': False, 'error': error_msg}}
                return {
                    'success': False,
                    'message': error_msg,
                    'message_type': 'error',
                    'template': 'admin/media_edit.html',
                    'data': {'media': media_item, 'media_types': media_types}
                }
            
            # Verify media type exists
            media_type = MediaType.query.get(media_type_id)
            if not media_type:
                error_msg = 'Invalid media type selected'
                if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                    return {'success': False, 'json_response': {'success': False, 'error': error_msg}}
                return {
                    'success': False,
                    'message': error_msg,
                    'message_type': 'error',
                    'template': 'admin/media_edit.html',
                    'data': {'media': media_item, 'media_types': media_types}
                }
            
            current_app.logger.info("[DEBUG] Basic validation passed, proceeding with field updates")
            
            # Parse release date if provided
            current_app.logger.info(f"[DEBUG] Processing release date: '{release_date_str}'")
            release_date = None
            if release_date_str:
                try:
                    release_date = datetime.strptime(release_date_str, '%Y-%m-%d')
                    current_app.logger.info(f"[DEBUG] Release date parsed successfully: {release_date}")
                except ValueError:
                    error_msg = 'Invalid release date format. Please use YYYY-MM-DD format.'
                    current_app.logger.error(f"[DEBUG] Release date parsing failed: {release_date_str}")
                    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                        return {'success': False, 'json_response': {'success': False, 'error': error_msg}}
                    return {
                        'success': False,
                        'message': error_msg,
                        'message_type': 'error',
                        'template': 'admin/media_edit.html',
                        'data': {'media': media_item, 'media_types': media_types}
                    }
            
            # Update media item
            media_item.title = title
            media_item.description = description
            media_item.media_type_id = media_type_id
            media_item.is_featured = is_featured
            media_item.adult = adult
            media_item.min_age = min_age
            # MediaShare Rating (0-100; blank clears)
            _user_score_val = (request.form.get('user_score') or '').strip()
            media_item.user_score = (_user_score_val if _user_score_val != '' else None)
            if imdb_rating is not None:
                media_item.imdb_rating = imdb_rating
            # IMDB ID (blank clears)
            media_item.imdb_id = (imdb_id if imdb_id != '' else None)
            media_item.release_date = release_date
            
            # Process genres from IMDb data
            imdb_genres_str = request.form.get('imdb_genres', '').strip()
            if imdb_genres_str:
                try:
                    # Remove existing genre associations
                    MediaGenre.query.filter_by(media_id=media_item.id).delete()
                    
                    # Parse comma-separated genres, dedupe (case-insensitive) preserving order
                    names_raw = [g.strip() for g in imdb_genres_str.split(',') if g.strip()]
                    seen = set()
                    genre_names = []
                    for n in names_raw:
                        k = n.lower()
                        if k in seen:
                            continue
                        seen.add(k)
                        genre_names.append(n)
                    current_app.logger.info(f"[DEBUG] Processing {len(genre_names)} unique genres (deduped): {genre_names}")
                    
                    for genre_name in genre_names:
                        if not genre_name:  # Skip empty genre names
                            continue
                            
                        # Link only existing genres; skip unknown names (no creation here)
                        genre = Genre.query.filter_by(name=genre_name).first()
                        if not genre:
                            current_app.logger.info(f"[DEBUG] Skipping unknown genre name: {genre_name}")
                            continue
                        
                        # Check if association already exists to prevent duplicates
                        existing_association = MediaGenre.query.filter_by(
                            media_id=media_item.id,
                            genre_id=genre.id
                        ).first()
                        
                        if not existing_association:
                            # Create media-genre association
                            media_genre = MediaGenre(
                                media_id=media_item.id,
                                genre_id=genre.id,
                                created_at=datetime.now(timezone.utc),
                                created_by=current_user.id
                            )
                            db.session.add(media_genre)
                            current_app.logger.info(f"[DEBUG] Created genre association: {genre_name}")
                        else:
                            current_app.logger.info(f"[DEBUG] Genre association already exists: {genre_name}")
                            
                except Exception as e:
                    current_app.logger.error(f"[DEBUG] Error processing genres: {str(e)}")
                    error_message = f'Error processing genres: {str(e)}'
                    
                    # Return JSON response for AJAX requests
                    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                        return {'success': False, 'json_response': {'success': False, 'error': error_message}}
                    
                    return {
                        'success': False,
                        'message': error_message,
                        'message_type': 'error',
                        'template': 'admin/media_edit.html',
                        'data': {'media': media_item, 'media_types': media_types}
                    }
            
            # Process directors from IMDb data
            imdb_directors_str = request.form.get('imdb_directors', '').strip()
            current_app.logger.info(f"[DEBUG] imdb_directors field value: '{imdb_directors_str}'")
            if imdb_directors_str:
                try:
                    # Remove existing director associations
                    MediaDirector.query.filter_by(media_id=media_item.id).delete()
                    
                    # Parse comma-separated directors, dedupe (case-insensitive) preserving order
                    names_raw = [d.strip() for d in imdb_directors_str.split(',') if d.strip()]
                    seen = set()
                    director_names = []
                    for n in names_raw:
                        k = n.lower()
                        if k in seen:
                            continue
                        seen.add(k)
                        director_names.append(n)
                    current_app.logger.info(f"[DEBUG] Processing {len(director_names)} unique directors (deduped): {director_names}")
                    
                    for director_name in director_names:
                        if not director_name:  # Skip empty director names
                            continue
                        
                        # Find existing director or create new one
                        director = Director.query.filter_by(name=director_name).first()
                        if not director:
                            # Create new director
                            director = Director(
                                name=director_name,
                                created_at=datetime.now(timezone.utc),
                                created_by=current_user.id
                            )
                            db.session.add(director)
                            db.session.flush()  # Flush to get the director ID
                            current_app.logger.info(f"[DEBUG] Created new director: {director_name}")
                        else:
                            current_app.logger.info(f"[DEBUG] Found existing director: {director_name}")
                        
                        # Check if association already exists to prevent duplicates
                        existing_association = MediaDirector.query.filter_by(
                            media_id=media_item.id,
                            director_id=director.id
                        ).first()
                        
                        if not existing_association:
                            # Create media-director association
                            media_director = MediaDirector(
                                media_id=media_item.id,
                                director_id=director.id,
                                created_at=datetime.now(timezone.utc),
                                created_by=current_user.id
                            )
                            db.session.add(media_director)
                            current_app.logger.info(f"[DEBUG] Created director association: {director_name}")
                        else:
                            current_app.logger.info(f"[DEBUG] Director association already exists: {director_name}")
                            
                except Exception as e:
                    current_app.logger.error(f"[DEBUG] Error processing directors: {str(e)}")
                    error_message = f'Error processing directors: {str(e)}'
                    
                    # Return JSON response for AJAX requests
                    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                        return {'success': False, 'json_response': {'success': False, 'error': error_message}}
                    
                    return {
                        'success': False,
                        'message': error_message,
                        'message_type': 'error',
                        'template': 'admin/media_edit.html',
                        'data': {'media': media_item, 'media_types': media_types}
                    }
            
            # Process cast/performers from IMDb data - Sonnet 4.5 | 2025-10-04
            imdb_cast_str = request.form.get('imdb_cast', '').strip()
            current_app.logger.info(f"[DEBUG] imdb_cast field value: '{imdb_cast_str}'")
            if imdb_cast_str:
                try:
                    # Remove existing performer associations
                    MediaPerformer.query.filter_by(media_id=media_item.id).delete()
                    
                    # Parse comma-separated cast members, dedupe (case-insensitive) preserving order
                    names_raw = [c.strip() for c in imdb_cast_str.split(',') if c.strip()]
                    seen = set()
                    cast_names = []
                    for n in names_raw:
                        k = n.lower()
                        if k in seen:
                            continue
                        seen.add(k)
                        cast_names.append(n)
                    current_app.logger.info(f"[DEBUG] Processing {len(cast_names)} unique cast members (deduped): {cast_names}")
                    
                    for cast_name in cast_names:
                        if not cast_name:  # Skip empty cast names
                            continue
                        
                        # Find existing performer or create new one
                        performer = Performer.query.filter_by(name=cast_name).first()
                        if not performer:
                            # Create new performer
                            performer = Performer(
                                name=cast_name,
                                created_at=datetime.now(timezone.utc),
                                created_by=current_user.id
                            )
                            db.session.add(performer)
                            db.session.flush()  # Flush to get the performer ID
                            current_app.logger.info(f"[DEBUG] Created new performer: {cast_name}")
                        else:
                            current_app.logger.info(f"[DEBUG] Found existing performer: {cast_name}")
                        
                        # Check if association already exists to prevent duplicates
                        existing_association = MediaPerformer.query.filter_by(
                            media_id=media_item.id,
                            performer_id=performer.id
                        ).first()
                        
                        if not existing_association:
                            # Create media-performer association
                            media_performer = MediaPerformer(
                                media_id=media_item.id,
                                performer_id=performer.id,
                                created_at=datetime.now(timezone.utc),
                                updated_at=datetime.now(timezone.utc),
                                created_by=current_user.id,
                                updated_by=current_user.id
                            )
                            db.session.add(media_performer)
                            current_app.logger.info(f"[DEBUG] Created performer association: {cast_name}")
                        else:
                            current_app.logger.info(f"[DEBUG] Performer association already exists: {cast_name}")
                            
                except Exception as e:
                    current_app.logger.error(f"[DEBUG] Error processing cast: {str(e)}")
                    error_message = f'Error processing cast: {str(e)}'
                    
                    # Return JSON response for AJAX requests
                    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                        return {'success': False, 'json_response': {'success': False, 'error': error_message}}
                    
                    return {
                        'success': False,
                        'message': error_message,
                        'message_type': 'error',
                        'template': 'admin/media_edit.html',
                        'data': {'media': media_item, 'media_types': media_types}
                    }
            
            # Process thumbnail_path from IMDb poster URL - Sonnet 4.5 | 2025-10-04
            thumbnail_path_str = request.form.get('thumbnail_path', '').strip()
            current_app.logger.info(f"[DEBUG] thumbnail_path field value: '{thumbnail_path_str}'")
            if thumbnail_path_str:
                media_item.thumbnail_path = thumbnail_path_str
                current_app.logger.info(f"[DEBUG] Updated thumbnail_path to: {thumbnail_path_str}")
            
            # Log the admin action
            try:
                UserAction.log_action(
                    user_id=current_user.id,
                    action_type='admin_edit_media',
                    action_category='admin',
                    details={
                        'media_id': media_item.id,
                        'media_title': media_item.title,
                        'edited_fields': ['title', 'description', 'media_type', 'is_featured', 'adult', 'min_age', 'user_score', 'imdb_rating', 'imdb_id', 'release_date']
                    },
                    ip_address=request.remote_addr,
                    user_agent=request.headers.get('User-Agent', ''),
                    target_type='media',
                    target_id=media_item.id
                )
                current_app.logger.info(f"[DEBUG] UserAction logged successfully for admin {current_user.id} editing media {media_item.id}")
            except Exception as e:
                current_app.logger.error(f"[DEBUG] Failed to log UserAction: {str(e)}")
                # Don't fail the entire operation if logging fails
            
            # Commit changes to database
            db.session.commit()
            success_message = 'Item saved.'
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accept_mimetypes.best == 'application/json':
                return {'success': True, 'json_response': {'success': True, 'message': success_message}}
            return {
                'success': True,
                'message': success_message,
                'message_type': 'success',
                'redirect': url_for('admin.media_edit', media_id=media_id)
            }
            
        except Exception as e:
            # Rollback on error
            db.session.rollback()
            error_message = f'Error updating media: {str(e)}'
            current_app.logger.error(f"[DEBUG] media_edit exception: {str(e)}")
            
            # Return JSON response for AJAX requests
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return {'success': False, 'json_response': {'success': False, 'error': error_message}}
            
            return {
                'success': False,
                'message': error_message,
                'message_type': 'error',
                'template': 'admin/media_edit.html',
                'data': {'media': media_item, 'media_types': media_types}
            }

    except Exception as e:
        current_app.logger.error(f"[DEBUG] Error in media_edit_util: {str(e)}")
        return {
            'success': False,
            'error': f'Error loading media edit: {str(e)}',
            'status_code': 500
        }



def upload_media_get_util():
    """
    Utility function to display the media upload form.
    
    This function handles the business logic for rendering the upload form
    with media types populated and owner preselected when provided.
    
    Returns:
        dict: Result containing success status and template data
    """
    try:
        # Get query parameters
        owner_user_id = request.args.get('owner_user_id', type=int)
        selected_media_type_id = request.args.get('media_type_id', type=int)
        
        # DEBUG: Log all query parameters
        current_app.logger.info(f"[DEBUG] upload_media GET - All query args: {dict(request.args)}")
        current_app.logger.info(f"[DEBUG] upload_media GET - owner_user_id: {owner_user_id} (type: {type(owner_user_id)})")
        current_app.logger.info(f"[DEBUG] upload_media GET - selected_media_type_id: {selected_media_type_id}")
        
        # Load MediaTypes list ordered by name
        media_types = MediaType.query.order_by(MediaType.name.asc()).all()
        
        # Prepare owner summary and validation if owner_user_id is present
        owner_summary = None
        owner_invalid = False
        
        if owner_user_id:
            current_app.logger.info(f"[DEBUG] Looking up owner with user_id: {owner_user_id}")
            # Fetch user by primary key without pre-filtering by is_active
            user = User.query.get(owner_user_id)
            
            if user:
                current_app.logger.info(f"[DEBUG] Found user: {user.username}, is_active: {user.is_active}")
                # Check if user is active after fetching
                if user.is_active:
                    owner_summary = {
                        'id': user.id,
                        'username': user.username,
                        'email': user.email,
                        'is_active': user.is_active
                    }
                    current_app.logger.info(f"[DEBUG] Owner summary created for active user: {user.username}")
                else:
                    current_app.logger.info(f"[DEBUG] User {user.username} exists but is inactive")
                    owner_invalid = True
            else:
                current_app.logger.info(f"[DEBUG] No user found with id: {owner_user_id}")
                owner_invalid = True
        else:
            current_app.logger.info("[DEBUG] No owner_user_id parameter provided")
        
        # Prepare context for template
        context = {
            'owner_user_id': owner_user_id,
            'owner_summary': owner_summary,
            'owner_invalid': owner_invalid,
            'media_types': media_types,
            'selected_media_type_id': selected_media_type_id
        }
        
        # DEBUG: Log final context being passed to template
        current_app.logger.info(f"[DEBUG] Final template context - owner_user_id: {context['owner_user_id']}")
        current_app.logger.info(f"[DEBUG] Final template context - owner_summary: {context['owner_summary']}")
        current_app.logger.info(f"[DEBUG] Final template context - owner_invalid: {context['owner_invalid']}")
        
        return {
            'success': True,
            'template': 'admin/media_upload.html',
            'data': context
        }
        
    except Exception as e:
        current_app.logger.error(f"[DEBUG] Error in upload_media GET: {str(e)}")
        return {
            'success': False,
            'message': 'Error loading upload form',
            'message_type': 'error',
            'redirect': url_for('admin.media')
        }


def upload_media_post_util():
    """
    Utility function to process media upload form submission.
    
    This function handles the business logic for file uploads, validation,
    storage, and database record creation.
    
    Returns:
        dict: Result containing success status and redirect info
    """
    try:
        
        # Validate CSRF token if enabled
        if current_app.config.get('WTF_CSRF_ENABLED') is True:
            try:
                validate_csrf(request.form.get('csrf_token'))
                current_app.logger.info("[DEBUG] CSRF token validation passed for upload_media_post")
            except Exception as e:
                current_app.logger.error(f"[DEBUG] CSRF token validation failed for upload_media_post: {str(e)}")
                return {
                    'success': False,
                    'message': 'Security token validation failed. Please try again.',
                    'message_type': 'error',
                    'redirect': url_for('admin.upload_media')
                }
        
        # Get form data
        owner_user_id = request.form.get('owner_user_id', type=int)
        media_type_id = request.form.get('media_type_id', type=int)
        
        # Log upload attempt
        current_app.logger.info(f"[DEBUG] Upload attempt - owner_user_id: {owner_user_id}, media_type_id: {media_type_id}")
        
        # Validate required fields
        if not owner_user_id:
            return {
                'success': False,
                'message': 'Please select an owner for the media.',
                'message_type': 'error',
                'redirect': url_for('admin.upload_media')
            }
        
        if not media_type_id:
            return {
                'success': False,
                'message': 'Please select a media type.',
                'message_type': 'error',
                'redirect': url_for('admin.upload_media', owner_user_id=owner_user_id)
            }
        
        # Verify owner exists and is active
        owner = User.query.get(owner_user_id)
        if not owner:
            return {
                'success': False,
                'message': 'Selected owner not found.',
                'message_type': 'error',
                'redirect': url_for('admin.upload_media')
            }
        
        if not owner.is_active:
            return {
                'success': False,
                'message': 'Selected owner is not active.',
                'message_type': 'error',
                'redirect': url_for('admin.upload_media')
            }
        
        # Verify media type exists
        media_type = MediaType.query.get(media_type_id)
        if not media_type:
            return {
                'success': False,
                'message': 'Selected media type not found.',
                'message_type': 'error',
                'redirect': url_for('admin.upload_media', owner_user_id=owner_user_id)
            }
            
        # Get uploaded files
        uploaded_files = request.files.getlist('file')
        
        # Filter out empty file entries (browsers often include empty file slots)
        valid_files = [f for f in uploaded_files if f and f.filename != '']
        
        if not valid_files:
            return {
            'success': False,
            'message': 'Please select at least one file to upload.',
            'message_type': 'error',
            'redirect': url_for('admin.upload_media', owner_user_id=owner_user_id, media_type_id=media_type_id)
        }
        
        # Media processing utilities already imported from media_core at top of file
        # Process uploaded files using media_core function
        successful_uploads, error_messages = process_uploaded_files(
            valid_files,
            owner_user_id,
            media_type.code
        )
        
        # Save successful uploads to database
        saved_count = 0
        for file_info in successful_uploads:
            try:
                # Create new media record
                new_media = Media(
                    users_id=owner_user_id,
                    media_type_id=media_type_id,
                    title=file_info['filename_original'].rsplit('.', 1)[0],  # Use filename without extension as title
                    description=f"Uploaded by admin for {owner.username}",
                    filename_original=file_info['filename_original'],
                    filename_stored=file_info['filename_stored'],
                    file_path=file_info['file_path'],
                    file_size_bytes=file_info['file_size_bytes'],
                    mime_type=file_info['mime_type'],
                    file_hash=file_info['file_hash'],
                    thumbnail_path=file_info.get('thumbnail_path'),
                    media_metadata=file_info.get('media_metadata', {}),
                    tags='',
                    is_public=False,  # Default to private
                    is_featured=False,
                    is_processed=True,  # Mark as processed since we saved it
                    processing_status='completed',
                    download_count=0,
                    view_count=0,
                    like_count=0,
                    credit_cost=media_type.credit_cost,
                    adult=False,
                    min_age=0,
                    created_at=datetime.now(timezone.utc),
                    created_by=current_user.id
                )
                
                db.session.add(new_media)
                saved_count += 1
                
                # Log the upload action
                try:
                    UserAction.log_action(
                        user_id=current_user.id,
                        action_type='admin_upload_media',
                        action_category='admin',
                        details={
                            'owner_user_id': owner_user_id,
                            'owner_username': owner.username,
                            'media_type': media_type.name,
                            'filename': file_info['filename_original'],
                            'file_size_mb': round(file_info['file_size_bytes'] / (1024 * 1024), 2)
                        },
                        ip_address=request.remote_addr,
                        user_agent=request.headers.get('User-Agent', ''),
                        target_type='media',
                        target_id=None  # Will be set after commit
                    )
                except Exception as e:
                    current_app.logger.error(f"[DEBUG] Failed to log UserAction: {str(e)}")
                
            except Exception as e:
                current_app.logger.error(f"[DEBUG] Error saving media to database: {str(e)}")
                error_messages.append(f"{file_info['filename_original']}: Database save failed")
        
        # Commit all database changes
        if saved_count > 0:
            try:
                db.session.commit()
                current_app.logger.info(f"[DEBUG] Successfully saved {saved_count} media files to database")
            except Exception as e:
                db.session.rollback()
                current_app.logger.error(f"[DEBUG] Database commit failed: {str(e)}")
                return {
                    'success': False,
                    'message': 'Error saving media to database. Files were uploaded but not recorded.',
                    'message_type': 'error',
                    'redirect': url_for('admin.upload_media')
                }
        
        # Determine success/error messages and redirect
        messages = []
        if saved_count > 0:
            messages.append(('success', f'Successfully uploaded {saved_count} file(s).'))
        
        if error_messages:
            for error in error_messages:
                messages.append(('error', f'Error: {error}'))
        
        # Determine redirect based on results
        if saved_count > 0 and not error_messages:
            # All successful, go to media list
            redirect_url = url_for('admin.media')
        else:
            # Some errors, stay on upload page
            redirect_url = url_for('admin.upload_media', owner_user_id=owner_user_id, media_type_id=media_type_id)
        
        return {
            'success': True,
            'messages': messages,
            'redirect': redirect_url
        }
        
    except Exception as e:
        import traceback
        current_app.logger.error(f"[DEBUG] Error in upload_media_post: {str(e)}")
        current_app.logger.error(f"[DEBUG] Full traceback: {traceback.format_exc()}")
        # Return a failure response so the request doesn't hang
        return {
            'success': False,
            'message': 'An unexpected error occurred during processing.',
            'message_type': 'error',
            'redirect': url_for('admin.upload_media')
        }


def select_owner_util():
    """
    Utility function to display the owner selection page.
    
    This function handles the business logic for owner selection
    with filtering and pagination.
    
    Returns:
        dict: Result containing success status and template data
    """
    try:
        # Get and validate query parameters
        next_url = request.args.get('next', '/admin/media/upload')
        show_all = request.args.get('show_all', '').lower() in ('true', '1', 'on', 'yes')
        resellers_only = request.args.get('resellers_only', '').lower() in ('true', '1', 'on', 'yes')
        page = request.args.get('page', 1, type=int)
        
        # Accept both 'q' and 'search' parameters for backward compatibility
        search_term = request.args.get('q', '').strip()
        if not search_term:
            search_term = request.args.get('search', '').strip()
        
        # Log effective filters for debugging
        current_app.logger.info(f"[DEBUG] select_owner filters - show_all: {show_all}, resellers_only: {resellers_only}, search_term: '{search_term}', page: {page}")
        
        # Validate and sanitize next parameter - only allow /admin/media/upload
        if not next_url.startswith('/admin/media/upload'):
            next_url = '/admin/media/upload'
        
        # Build base query
        query = db.session.query(User)
        
        # Apply active filter (default: active users only)
        if not show_all:
            query = query.filter(User.is_active == True)
        
        # Apply resellers filter if requested
        if resellers_only:
            # Filter for reseller user type only
            reseller_type = UserType.query.filter_by(code='reseller').first()
            if reseller_type:
                query = query.filter(User.users_type_id == reseller_type.id)
        
        # Apply search filter if provided
        if search_term:
            search_pattern = f'%{search_term}%'
            query = query.filter(
                or_(
                    User.username.ilike(search_pattern),
                    User.email.ilike(search_pattern)
                )
            )
        
        # Sort by username ascending
        query = query.order_by(User.username.asc())
        
        # Pagination: 20 per page
        per_page = 20
        total = query.count()
        offset = (page - 1) * per_page
        users = query.offset(offset).limit(per_page).all()
        
        # Calculate pagination info
        pages = (total + per_page - 1) // per_page  # Ceiling division
        has_next = page < pages
        has_prev = page > 1
        
        # Prepare user data with reseller flag
        user_data = []
        for user in users:
            is_reseller = user.user_type and user.user_type.code == 'reseller'
            user_data.append({
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'is_active': user.is_active,
                'is_reseller': is_reseller
            })
        
        # Prepare context
        context = {
            'users': user_data,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': total,
                'pages': pages,
                'has_next': has_next,
                'has_prev': has_prev
            },
            'filters': {
                'show_all': show_all,
                'resellers_only': resellers_only,
                'q': search_term,
                'sort_label': 'Username (A-Z)'
            },
            'next': next_url
        }
        
        return {
            'success': True,
            'template': 'admin/select_owner.html',
            'data': context
        }
        
    except Exception as e:
        current_app.logger.error(f"[DEBUG] Error in select_owner: {str(e)}")
        return {
            'success': False,
            'error': 'Error loading owner selection',
            'status_code': 500
        }


def select_owner_search_util():
    """
    Utility function for AJAX endpoint for owner selection search.
    
    This function handles the business logic for owner selection
    with pagination support via AJAX.
    
    Returns:
        dict: Result containing success status and JSON response data
    """
    try:
        # Get query parameters - accept both 'term' and 'q'/'search' for backward compatibility
        search_term = request.args.get('term', '').strip()
        if not search_term:
            search_term = request.args.get('q', '').strip()
        if not search_term:
            search_term = request.args.get('search', '').strip()
            
        active_only = request.args.get('active_only', 'true').lower() in ('true', '1')
        resellers_only = request.args.get('resellers_only', 'false').lower() in ('true', '1')
        limit = request.args.get('limit', 20, type=int)
        page = request.args.get('page', 1, type=int)
        
        # Log effective filters for debugging
        current_app.logger.info(f"[DEBUG] select_owner_search filters - search_term: '{search_term}', active_only: {active_only}, resellers_only: {resellers_only}, limit: {limit}, page: {page}")
        
        # Validate search term
        if not search_term:
            return {
                'success': True,
                'json_response': {
                    'users': [],
                    'pagination': {
                        'page': page,
                        'per_page': limit,
                        'total': 0,
                        'pages': 0,
                        'has_next': False,
                        'has_prev': False
                    }
                }
            }
        
        # Build base query
        query = db.session.query(User)
        
        # Apply active filter
        if active_only:
            query = query.filter(User.is_active == True)
        
        # Apply resellers filter if requested
        if resellers_only:
            # Filter for reseller user type only
            reseller_type = UserType.query.filter_by(code='reseller').first()
            if reseller_type:
                query = query.filter(User.users_type_id == reseller_type.id)
        
        # Apply search filter
        search_pattern = f'%{search_term}%'
        query = query.filter(
            or_(
                User.username.ilike(search_pattern),
                User.email.ilike(search_pattern)
            )
        )
        
        # Sort by username ascending
        query = query.order_by(User.username.asc())
        
        # Pagination: calculate total and apply offset/limit
        per_page = limit
        total = query.count()
        offset = (page - 1) * per_page
        users = query.offset(offset).limit(per_page).all()
        
        # Calculate pagination info
        pages = (total + per_page - 1) // per_page  # Ceiling division
        has_next = page < pages
        has_prev = page > 1
        
        # Prepare user data with reseller flag
        user_data = []
        for user in users:
            is_reseller = user.user_type and user.user_type.code == 'reseller'
            user_data.append({
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'is_active': user.is_active,
                'is_reseller': is_reseller
            })
        
        # Return paginated response matching data contract
        return {
            'success': True,
            'json_response': {
                'users': user_data,
                'pagination': {
                    'page': page,
                    'per_page': per_page,
                    'total': total,
                    'pages': pages,
                    'has_next': has_next,
                    'has_prev': has_prev
                }
            }
        }
        
    except Exception as e:
        current_app.logger.error(f"[DEBUG] Error in select_owner_search: {str(e)}")
        return {
            'success': False,
            'json_response': {'error': 'Search failed'},
            'status_code': 500
        }



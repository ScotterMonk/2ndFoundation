"""
User utility functions for media operations.

This module contains utility functions for user media operations that are called
from user routes. Functions here act as wrappers around core functionality,
adding user-specific context, permissions, and logging.

These functions delegate business logic to core modules while handling
user-appropriate access controls and Flask context.
"""

from flask import request, current_app, jsonify
from flask_login import current_user
from datetime import datetime, timezone
from sqlalchemy import func, and_, or_, distinct
from sqlalchemy.orm import joinedload
from utils.database import db
from typing import Optional, Dict, List, Any, Tuple

# Import required models
from models.models_user import User, UserType, UserAction
from models.models_media import Media, MediaType, Genre, MediaGenre, Director

# Import core modules for business logic
from utils.media_core import merge_and_deduplicate_results, validate_file, save_uploaded_file
from utils.imdb_core import imdb_search_core, imdb_details_fetch_core, imdb_search_for_media_core


def search_media_for_user(search_term: Optional[str] = None, 
                         genre_id: Optional[int] = None,
                         media_type_id: Optional[int] = None,
                         page: int = 1,
                         per_page: int = 20,
                         sort_by: str = 'created_at',
                         sort_direction: str = 'desc') -> Dict[str, Any]:
    """
    Search media for regular users with appropriate access controls.
    
    This function acts as a wrapper around core media search functionality,
    applying user-specific permissions and logging user search activity.
    
    Args:
        search_term: Search query string
        genre_id: Optional genre filter
        media_type_id: Optional media type filter
        page: Page number for pagination
        per_page: Items per page
        sort_by: Field to sort by
        sort_direction: Sort direction ('asc' or 'desc')
        
    Returns:
        dict: Search results with user-appropriate data and pagination
    """
    try:
        # Log user search activity
        if current_user and current_user.is_authenticated:
            try:
                UserAction.log_action(
                    user_id=current_user.id,
                    action_type='user_media_search',
                    action_category='media',
                    details={
                        'search_term': search_term,
                        'genre_id': genre_id,
                        'media_type_id': media_type_id,
                        'sort_by': sort_by
                    },
                    ip_address=request.remote_addr,
                    user_agent=request.headers.get('User-Agent', ''),
                    target_type='search',
                    target_id=None
                )
            except Exception as e:
                current_app.logger.warning(f"Failed to log user search action: {str(e)}")
        
        # Build base query with user access restrictions
        # Users can only see public media or their own media
        base_query = (
            db.session.query(Media)
            .options(joinedload(Media.media_type))
            .join(User, Media.users_id == User.id)
            .join(MediaType, Media.media_type_id == MediaType.id)
        )
        
        # Apply user access control: only public media or own media
        if current_user and current_user.is_authenticated:
            base_query = base_query.filter(
                or_(
                    Media.is_public == True,
                    Media.users_id == current_user.id
                )
            )
        else:
            # Anonymous users can only see public media
            base_query = base_query.filter(Media.is_public == True)
        
        # Apply search filter
        if search_term and search_term.strip():
            pattern = f'%{search_term.strip()}%'
            conditions = [
                Media.title.ilike(pattern),
                Media.description.ilike(pattern)
            ]
            # Don't expose user details in search for regular users
            base_query = base_query.filter(or_(*conditions))
        
        # Apply genre filter
        if genre_id:
            try:
                genre_id = int(genre_id)
                base_query = base_query.join(
                    MediaGenre, MediaGenre.media_id == Media.id
                ).filter(MediaGenre.genre_id == genre_id)
            except (ValueError, TypeError):
                pass
        
        # Apply media type filter
        if media_type_id:
            try:
                media_type_id = int(media_type_id)
                base_query = base_query.filter(Media.media_type_id == media_type_id)
            except (ValueError, TypeError):
                pass
        
        # Apply sorting
        sort_map = {
            'title': Media.title,
            'type': MediaType.name,
            'rating_user': Media.user_rating_100,
            'created_at': Media.created_at,
            'director': Director.name
        }
        sort_col = sort_map.get(sort_by, Media.created_at)
        order_clause = sort_col.asc() if sort_direction == 'asc' else sort_col.desc()
        
        # Get database results
        db_results = base_query.order_by(order_clause, Media.id.asc()).all()
        
        # Get IMDb search results if search term provided
        imdb_results = []
        if search_term and search_term.strip():
            try:
                # Use core IMDb search functionality
                genre_name = None
                if genre_id:
                    try:
                        genre = Genre.query.get(genre_id)
                        if genre:
                            genre_name = genre.name
                    except Exception:
                        pass
                
                imdb_results = imdb_search_for_media_core(
                    search_term=search_term.strip(),
                    genre_name=genre_name,
                    timeout=8  # Shorter timeout for user searches
                )
            except Exception as e:
                current_app.logger.warning(f"IMDb search failed for user: {str(e)}")
                imdb_results = []
        
        # Merge and deduplicate results using core functionality
        try:
            merged_results = merge_and_deduplicate_results(db_results, imdb_results)
        except Exception as e:
            current_app.logger.warning(f"Failed to merge search results: {str(e)}")
            merged_results = [_media_to_dict(m) for m in db_results]
        
        # Apply pagination
        total_results = len(merged_results)
        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        paged_results = merged_results[start_idx:end_idx]
        
        # Calculate pagination info
        total_pages = (total_results + per_page - 1) // per_page
        
        return {
            'success': True,
            'results': paged_results,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total_results': total_results,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_prev': page > 1
            },
            'search_params': {
                'search_term': search_term,
                'genre_id': genre_id,
                'media_type_id': media_type_id,
                'sort_by': sort_by,
                'sort_direction': sort_direction
            }
        }
        
    except Exception as e:
        current_app.logger.error(f"Error in search_media_for_user: {str(e)}")
        return {
            'success': False,
            'error': 'Search failed. Please try again.',
            'results': [],
            'pagination': {
                'page': 1,
                'per_page': per_page,
                'total_results': 0,
                'total_pages': 0,
                'has_next': False,
                'has_prev': False
            }
        }


def get_media_details_for_user(media_id: int, include_imdb: bool = True) -> Dict[str, Any]:
    """
    Get detailed media information for users with appropriate access controls.
    
    This function retrieves media details while respecting user permissions
    and optionally enriches data with IMDb information.
    
    Args:
        media_id: ID of the media item
        include_imdb: Whether to fetch additional IMDb data
        
    Returns:
        dict: Media details with user-appropriate access
    """
    try:
        # Get media item with access control
        media_query = (
            Media.query
            .options(joinedload(Media.media_type))
            .options(joinedload(Media.director))
        )
        
        if current_user and current_user.is_authenticated:
            # Users can access public media or their own media
            media = media_query.filter(
                Media.id == media_id,
                or_(
                    Media.is_public == True,
                    Media.users_id == current_user.id
                )
            ).first()
        else:
            # Anonymous users can only access public media
            media = media_query.filter(
                Media.id == media_id,
                Media.is_public == True
            ).first()
        
        if not media:
            return {
                'success': False,
                'error': 'Media not found or access denied',
                'media': None
            }
        
        # Log user view activity
        if current_user and current_user.is_authenticated:
            try:
                UserAction.log_action(
                    user_id=current_user.id,
                    action_type='user_media_view',
                    action_category='media',
                    details={
                        'media_id': media_id,
                        'media_title': media.title,
                        'include_imdb': include_imdb
                    },
                    ip_address=request.remote_addr,
                    user_agent=request.headers.get('User-Agent', ''),
                    target_type='media',
                    target_id=media_id
                )
            except Exception as e:
                current_app.logger.warning(f"Failed to log media view action: {str(e)}")
        
        # Convert to user-safe dictionary
        media_dict = _media_to_user_dict(media)
        
        # Optionally enrich with IMDb data
        imdb_data = None
        if include_imdb and media.imdb_id:
            try:
                # Use core IMDb functionality
                resolved_id, imdb_details, rating_100 = imdb_details_fetch_core(
                    media_obj=media,
                    timeout=8
                )
                if imdb_details:
                    imdb_data = {
                        'imdb_id': resolved_id,
                        'title': imdb_details.get('title'),
                        'description': imdb_details.get('description'),
                        'release_date': imdb_details.get('release_date'),
                        'content_rating': imdb_details.get('content_rating'),
                        'type': imdb_details.get('type'),
                        'rating_0_10': imdb_details.get('average_rating_0_10'),
                        'rating_0_100': rating_100,
                        'genres': imdb_details.get('genres', []),
                        'poster_url': imdb_details.get('poster')
                    }
            except Exception as e:
                current_app.logger.warning(f"Failed to fetch IMDb data for media {media_id}: {str(e)}")
        
        return {
            'success': True,
            'media': media_dict,
            'imdb_data': imdb_data,
            'user_can_edit': _user_can_edit_media(media)
        }
        
    except Exception as e:
        current_app.logger.error(f"Error in get_media_details_for_user: {str(e)}")
        return {
            'success': False,
            'error': 'Failed to load media details',
            'media': None
        }


def get_user_media_library(user_id: Optional[int] = None,
                          page: int = 1,
                          per_page: int = 20,
                          sort_by: str = 'created_at',
                          sort_direction: str = 'desc') -> Dict[str, Any]:
    """
    Get a user's media library with appropriate access controls.
    
    Args:
        user_id: User ID (defaults to current user)
        page: Page number for pagination
        per_page: Items per page
        sort_by: Field to sort by
        sort_direction: Sort direction
        
    Returns:
        dict: User's media library with pagination
    """
    try:
        # Determine target user
        if user_id is None:
            if not current_user or not current_user.is_authenticated:
                return {
                    'success': False,
                    'error': 'Authentication required',
                    'media': []
                }
            target_user_id = current_user.id
        else:
            # Users can only access their own library
            if not current_user or not current_user.is_authenticated or current_user.id != user_id:
                return {
                    'success': False,
                    'error': 'Access denied',
                    'media': []
                }
            target_user_id = user_id
        
        # Build query for user's media
        base_query = (
            Media.query
            .options(joinedload(Media.media_type))
            .options(joinedload(Media.director))
            .filter(Media.users_id == target_user_id)
        )
        
        # Apply sorting
        sort_map = {
            'title': Media.title,
            'type': MediaType.name,
            'rating_user': Media.user_rating_100,
            'created_at': Media.created_at,
            'is_public': Media.is_public
        }
        sort_col = sort_map.get(sort_by, Media.created_at)
        order_clause = sort_col.asc() if sort_direction == 'asc' else sort_col.desc()
        
        # Get total count for pagination
        total_count = base_query.count()
        
        # Apply pagination
        media_items = (
            base_query
            .order_by(order_clause, Media.id.desc())
            .offset((page - 1) * per_page)
            .limit(per_page)
            .all()
        )
        
        # Convert to user-safe dictionaries
        media_dicts = [_media_to_user_dict(media) for media in media_items]
        
        # Calculate pagination info
        total_pages = (total_count + per_page - 1) // per_page
        
        return {
            'success': True,
            'media': media_dicts,
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total_results': total_count,
                'total_pages': total_pages,
                'has_next': page < total_pages,
                'has_prev': page > 1
            }
        }
        
    except Exception as e:
        current_app.logger.error(f"Error in get_user_media_library: {str(e)}")
        return {
            'success': False,
            'error': 'Failed to load media library',
            'media': []
        }


def _media_to_dict(media) -> Dict[str, Any]:
    """
    Convert media ORM object to dictionary for API responses.
    
    Args:
        media: Media ORM object
        
    Returns:
        dict: Media data dictionary
    """
    try:
        return {
            'id': media.id if hasattr(media, 'id') else None,
            'title': media.title if hasattr(media, 'title') else '',
            'year': _year_from_media(media),
            'type': _media_type_str(media),
            'rating_user': getattr(media, 'user_rating_100', None),
            'image_url': getattr(media, 'thumbnail_path', None),
            'source': 'DB'
        }
    except Exception:
        return {
            'id': None,
            'title': '',
            'year': None,
            'type': '',
            'rating_user': None,
            'image_url': None,
            'source': 'DB'
        }


def _media_to_user_dict(media) -> Dict[str, Any]:
    """
    Convert media ORM object to user-safe dictionary.
    
    This function excludes sensitive information and formats data
    appropriately for user consumption.
    
    Args:
        media: Media ORM object
        
    Returns:
        dict: User-safe media data
    """
    try:
        return {
            'id': media.id,
            'title': media.title,
            'description': media.description,
            'media_type': {
                'id': media.media_type.id if media.media_type else None,
                'name': media.media_type.name if media.media_type else None,
                'code': media.media_type.code if media.media_type else None
            },
            'director': {
                'id': media.director.id if media.director else None,
                'name': media.director.name if media.director else None
            } if media.director else None,
            'release_date': media.release_date.isoformat() if media.release_date else None,
            'is_featured': media.is_featured,
            'is_public': media.is_public,
            'adult': media.adult,
            'min_age': media.min_age,
            'user_rating_100': media.user_rating_100,
            'imdb_id': media.imdb_id,
            'imdb_rating': media.imdb_rating,
            'thumbnail_path': media.thumbnail_path,
            'view_count': media.view_count,
            'like_count': media.like_count,
            'download_count': media.download_count,
            'credit_cost': media.credit_cost,
            'created_at': media.created_at.isoformat() if media.created_at else None,
            'is_owner': current_user and current_user.is_authenticated and media.users_id == current_user.id
        }
    except Exception as e:
        current_app.logger.warning(f"Error converting media to user dict: {str(e)}")
        return {
            'id': getattr(media, 'id', None),
            'title': getattr(media, 'title', ''),
            'description': getattr(media, 'description', ''),
            'is_owner': False
        }


def _user_can_edit_media(media) -> bool:
    """
    Check if current user can edit the given media item.
    
    Args:
        media: Media ORM object
        
    Returns:
        bool: True if user can edit, False otherwise
    """
    if not current_user or not current_user.is_authenticated:
        return False
    
    # Users can only edit their own media
    return media.users_id == current_user.id


def _year_from_media(media):
    """Extract year from media object."""
    for attr in ('release_date', 'added_date', 'created_at'):
        dt = getattr(media, attr, None)
        if dt:
            try:
                return str(dt.year)
            except Exception:
                continue
    return None


def _media_type_str(media):
    """Extract media type string from media object."""
    try:
        mt = getattr(media, 'media_type', None)
        if mt:
            return (getattr(mt, 'code', None) or getattr(mt, 'name', None) or '').strip().lower()
    except Exception:
        pass
    try:
        ct = (getattr(media, 'content_type', None) or '').strip().lower()
        return ct
    except Exception:
        return ''
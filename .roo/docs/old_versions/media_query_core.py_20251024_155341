# Created by GPT-5 | 2025-10-24
"""
Core query builders for media search.
No Flask imports.
"""

from typing import Optional, List, Dict, Any
from sqlalchemy.orm import Query
from models.models_media import Media, Genre, MediaGenre
from utils.media_core import _created_sort_tuple, _title_tuple, _type_tuple, _rating_tuple

# Created by GPT-5 | 2025-10-24
def build_media_search_query(db_session, search_term, genre_id: Optional[int] = None):
    """
    Builds an SQLAlchemy query for media search with filters.
    
    Args:
        db_session: The SQLAlchemy database session.
        search_term (str): The search term to filter media titles by.
        genre_id (int, optional): The ID of the genre to filter by. Defaults to None.
        
    Returns:
        SQLAlchemy query: A query object with filters applied.
    """
    # Normalize base query
    query = db_session.query(Media)

    # Apply title search if provided (case-insensitive)
    if search_term:
        term = f"%{str(search_term).strip()}%"
        query = query.filter(Media.title.ilike(term))

    # Apply genre filter via explicit joins for SQL-side filtering
    if genre_id is not None:
        query = (
            query.join(MediaGenre, MediaGenre.media_id == Media.id)
                 .join(Genre, Genre.id == MediaGenre.genre_id)
                 .filter(Genre.id == genre_id)
                 .distinct()  # prevent duplicates due to joins
        )

    return query


# Created by GPT-5 | 2025-10-24
def normalize_media_results(media_list: List[Any]) -> List[Dict[str, Any]]:
    """
    Normalizes a list of Media ORM objects into a consistent dictionary format
    for template display.
    
    Args:
        media_list (list): A list of Media SQLAlchemy ORM objects.
        
    Returns:
        list: A list of dictionaries, each representing a normalized media item
              with keys: id, title, rating, created_at, media_type, owner_username.
    """
    normalized: List[Dict[str, Any]] = []
    if not media_list:
        return normalized

    for media in media_list:
        # created_at formatting
        created_str = None
        created_val = getattr(media, 'created_at', None)
        if created_val is not None:
            try:
                created_str = created_val.strftime('%Y-%m-%d %H:%M:%S')
            except Exception:
                # Fallback to str if not a datetime-like object
                try:
                    created_str = str(created_val)
                except Exception:
                    created_str = None

        # media_type name (relationship expected)
        mt = getattr(media, 'media_type', None)
        media_type_name = getattr(mt, 'name', None) if mt is not None else None

        # owner username (relationship expected: .owner; fallback-safe with getattr)
        owner = getattr(media, 'owner', None)
        owner_username = getattr(owner, 'username', None) if owner is not None else None

        item: Dict[str, Any] = {
            'id': getattr(media, 'id', None),
            'title': getattr(media, 'title', None),
            'rating': getattr(media, 'rating', None),
            'created_at': created_str,
            'media_type': media_type_name,
            'owner_username': owner_username,
        }
        normalized.append(item)

    return normalized


# Created by GPT-5 | 2025-10-24
def sort_media_results(results: list[dict], sort_field: str, direction: str) -> list[dict]:
    """
    Sorts a list of normalized media results (dictionaries) based on the specified field and direction.
    
    Args:
        results (list[dict]): A list of normalized media dictionaries.
        sort_field (str): The field to sort by (eg, 'rating', 'title', 'type', 'created_at').
        direction (str): The sort direction ('asc' or 'desc').
        
    Returns:
        list[dict]: The sorted list of media dictionaries.
    """
    # Handle empty input fast-path
    if not results:
        return []

    # Normalize inputs
    sort = (sort_field or '').strip().lower()
    dir_desc = (str(direction or '').strip().lower() == 'desc')

    # Map sort_field to existing helper that returns (missing_flag, value)
    helper_map = {
        'created_at': _created_sort_tuple,
        'title': _title_tuple,
        'type': _type_tuple,
        'rating': _rating_tuple,
    }
    helper = helper_map.get(sort)
    if not helper:
        # Unknown sort field -> return as-is
        return list(results)

    # Adapter to align normalized keys to helper expectations without mutating originals
    def adapter(item: dict) -> dict:
        # helpers expect 'type'; normalized uses 'media_type'
        if sort == 'type' and 'type' not in item:
            new_item = dict(item)
            new_item['type'] = item.get('media_type')
            return new_item
        return item

    # Two-pass stable sort:
    # 1) Sort by value with direction
    primary_sorted = sorted(results, key=lambda i: helper(adapter(i))[1], reverse=dir_desc)
    # 2) Stable sort by missing-flag to keep missing values last in both directions
    final_sorted = sorted(primary_sorted, key=lambda i: helper(adapter(i))[0])
    return final_sorted